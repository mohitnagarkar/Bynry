-- Companies
CREATE TABLE companies (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) UNIQUE NOT NULL
);

-- Warehouses
CREATE TABLE warehouses (
    id SERIAL PRIMARY KEY,
    company_id INT NOT NULL,
    name VARCHAR(255) NOT NULL,
    FOREIGN KEY (company_id) REFERENCES companies(id)
);

-- Suppliers
CREATE TABLE suppliers (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    contact_email VARCHAR(255)
);

-- Products
CREATE TABLE products (
    id SERIAL PRIMARY KEY,
    name VARCHAR(255) NOT NULL,
    sku VARCHAR(100) UNIQUE NOT NULL,
    is_bundle BOOLEAN DEFAULT FALSE
);

-- Product-Supplier relation
CREATE TABLE product_suppliers (
    product_id INT,
    supplier_id INT,
    PRIMARY KEY (product_id, supplier_id),
    FOREIGN KEY (product_id) REFERENCES products(id),
    FOREIGN KEY (supplier_id) REFERENCES suppliers(id)
);

-- Inventory per product per warehouse
CREATE TABLE inventories (
    id SERIAL PRIMARY KEY,
    product_id INT NOT NULL,
    warehouse_id INT NOT NULL,
    quantity INT DEFAULT 0,
    UNIQUE (product_id, warehouse_id),
    FOREIGN KEY (product_id) REFERENCES products(id),
    FOREIGN KEY (warehouse_id) REFERENCES warehouses(id)
);

-- Inventory change logs
CREATE TABLE inventory_logs (
    id SERIAL PRIMARY KEY,
    inventory_id INT NOT NULL,
    change_amount INT NOT NULL,
    change_type VARCHAR(50),
    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (inventory_id) REFERENCES inventories(id)
);

-- Bundle structure
CREATE TABLE product_bundles (
    bundle_id INT,
    component_product_id INT,
    quantity INT DEFAULT 1,
    PRIMARY KEY (bundle_id, component_product_id),
    FOREIGN KEY (bundle_id) REFERENCES products(id),
    FOREIGN KEY (component_product_id) REFERENCES products(id)
);



Questions to be asked for product team:
Should bundles be pre-stocked, or assembled on demand?
Should product prices be tracked by supplier or be global?
Do suppliers deliver to companies or directly to warehouses?
Should we track batch numbers, expiration dates, or serials?


Table: companies
Design:
id SERIAL PRIMARY KEY,  
name VARCHAR(255) UNIQUE NOT NULL

Justification:

SERIAL for auto-incrementing unique identifiers.
name is set to UNIQUE to prevent duplicate company records (e.g., "Amazon" twice).
NOT NULL ensures that company entries always have a valid name.

 Table: warehouses
Design:

Each warehouse has a company_id (foreign key) to represent ownership.
name is required to identify the warehouse.

Justification:

Supports one-to-many relationship: one company can have multiple warehouses.
Foreign key constraint ensures referential integrity with companies.

Table: suppliers
Design:
name is required; contact_email is optional.

Justification:

Simple model with optional contact info.
No uniqueness enforced on name in case suppliers have similar names.

 Table: products
Design:
Fields: name, sku, is_bundle.
sku is set as UNIQUE and NOT NULL.

Justification:

Ensures global SKU uniqueness, crucial for identifying products across warehouses/companies.
is_bundle allows product to be marked as a composite/bundle.


Table: product_suppliers
Design:
Many-to-many relationship between products and suppliers.
Composite primary key (product_id, supplier_id) ensures no duplicate entries.

Justification:

Allows tracking which supplier provides which products.
Enforces uniqueness of each relationship and maintains normalized schema.


Table: inventories
Design:
Represents inventory per product per warehouse.
Unique constraint on (product_id, warehouse_id).

Justification:

Ensures thereâ€™s only one inventory record per product per warehouse.
Quantity defaults to 0, simplifying insertions.
Ensures normalized handling of stock levels.



Table: inventory_logs
Design:
Tracks historical changes in inventory.
Includes change_type, timestamp, and change_amount.

Justification:

Enables auditing and tracking of all stock movements (in, out, adjustments).
Timestamp auto-defaults to current time for logging purposes.
Helps with debugging and reporting (e.g., stock movement trends)



Table: product_bundles
Design:
Represents composition of bundles.
Composite key on (bundle_id, component_product_id).

Justification:

Enables recursive product relationships (product contains other products).
Avoids product duplication in a bundle.
Quantity indicates how many of each component is in the bundle.
Allows flexible bundle definition for marketing or shipping.

